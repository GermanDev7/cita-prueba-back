
import { AppointmentRepository } from '../repositories/AppointmentRepository';
import { DoctorRepository } from '../repositories/DoctorRepository';
import { Appointment } from '../models/Appointment';

export class AppointmentService {
  constructor(
    private appointmentRepo: AppointmentRepository,
    private doctorRepo: DoctorRepository
  ) { }

  /**
   * Creates a new appointment while checking:
   * 1. The appointment is not in the past.
   * 2. The doctor is available in the specified time slot.
   * 3. The doctor has no conflicting appointments at that time.
   * 4. The patient does not already have an appointment at that time.
   */
  public async createAppointment(data: {
    dateTime: Date;
    appointmentType: string;
    userId: number;
    doctorId: number;
  }): Promise<Appointment> {
    // Ensure the appointment is scheduled in the future
    if (data.dateTime < new Date()) {
      throw new Error('Cannot schedule an appointment in the past');
    }

    // Get the day of the week for schedule validation
    const dayOfWeek = this.getDayOfWeek(data.dateTime);
    const schedules = await this.doctorRepo.getSchedulesByDoctorAndDay(data.doctorId, dayOfWeek);

    if (!this.isWithinSchedule(data.dateTime, schedules)) {
      throw new Error('Doctor is not available at this time');
    }

    // Check if the doctor already has an appointment at this time
    const doctorConflict = await this.appointmentRepo.hasConflictingAppointment(data.doctorId, data.dateTime);
    if (doctorConflict) {
      throw new Error('There is already an appointment for this doctor at this time');
    }

    // Check if the patient already has an appointment at this time
    const patientConflict = await this.appointmentRepo.hasConflictingPatientAppointment(data.userId, data.dateTime);
    if (patientConflict) {
      throw new Error('The patient already has an appointment at this time');
    }

    // Create a new appointment
    const newAppointment = new Appointment(
      0, // ID will be generated by the DB
      data.dateTime,
      data.appointmentType,
      'scheduled', // initial status
      data.userId,
      data.doctorId
    );
    return this.appointmentRepo.create(newAppointment);
  }

  /**
   * Returns a list of appointments for a given user.
   */
  public async listAppointments(userId: number): Promise<Appointment[]> {
    return this.appointmentRepo.findAllByUser(userId);
  }
  /**
   * Returns a list of appointments for a given doctor.
   */
  public async listAppointmentsByDoctor(userId: number): Promise<Appointment[]> {
    // First, retrieve the doctor's profile using the user's id.
    const doctorProfile = await this.doctorRepo.getDoctorProfileByUserId(userId);
    if (!doctorProfile) {
      throw new Error('Doctor profile not found');
    }
    // Then, get all appointments for this doctor using the doctor_id
    return this.appointmentRepo.findAllByDoctor(doctorProfile.doctor.doctorId);
  }

  /**
   * Returns a list of appointments for a given admin.
   */
  public async listAllAppointments(): Promise<Appointment[]> {
    return this.appointmentRepo.findAllAppointments();
  }
  

  /**
   * Updates an existing appointment (date/time and type).
   * It ensures the appointment is still scheduled, is not too close to its time (e.g. less than 2 hours), 
   * and validates that both doctor and patient have no conflicts at the new time.
   */
  public async updateAppointment(appointmentId: number, data: { dateTime: Date; appointmentType: string }): Promise<Appointment> {
    // Retrieve the current appointment (assumes findById exists)
    const appointment = await this.appointmentRepo.findById(appointmentId);
    if (!appointment) {
      throw new Error('Appointment not found');
    }
    // Only scheduled appointments can be updated
    if (appointment.status !== 'scheduled') {
      throw new Error('Only scheduled appointments can be updated');
    }
    // Prevent updating if less than 2 hours remain until the appointment
    const now = new Date();
    const diffHours = (appointment.dateTime.getTime() - now.getTime()) / (1000 * 60 * 60);
    const minHoursBeforeUpdate = 2;
    if (diffHours < minHoursBeforeUpdate) {
      throw new Error(`Cannot update appointment less than ${minHoursBeforeUpdate} hours before the scheduled time`);
    }
    // Validate the new appointment time is in the future
    if (data.dateTime < new Date()) {
      throw new Error('Cannot set appointment in the past');
    }
    // Validate doctor availability at the new time
    const dayOfWeek = this.getDayOfWeek(data.dateTime);
    const schedules = await this.doctorRepo.getSchedulesByDoctorAndDay(appointment.doctorId, dayOfWeek);
    if (!this.isWithinSchedule(data.dateTime, schedules)) {
      throw new Error('Doctor is not available at the new time');
    }
    // Check for conflicting appointments for the doctor
    const doctorConflict = await this.appointmentRepo.hasConflictingAppointment(appointment.doctorId, data.dateTime);
    if (doctorConflict) {
      throw new Error('There is already another appointment for this doctor at the new time');
    }
    // Check for conflicting appointments for the patient
    const patientConflict = await this.appointmentRepo.hasConflictingPatientAppointment(appointment.userId, data.dateTime);
    if (patientConflict) {
      throw new Error('The patient already has another appointment at the new time');
    }
    // Update the appointment with the new data
    appointment.dateTime = data.dateTime;
    appointment.appointmentType = data.appointmentType;
    return this.appointmentRepo.update(appointment);
  }

  /**
   * Reassigns the doctor for an appointment.
   * Validates that the appointment is still scheduled and the new doctor is available and conflict-free.
   */
  public async reassignDoctor(appointmentId: number, newDoctorId: number): Promise<void> {
    // Retrieve the current appointment
    const appointment = await this.appointmentRepo.findById(appointmentId);
    if (!appointment) {
      throw new Error('Appointment not found');
    }
    // Only scheduled appointments can be reassigned
    if (appointment.status !== 'scheduled') {
      throw new Error('Only scheduled appointments can be reassigned');
    }
    // Validate new doctor's availability for the appointment's time
    const dayOfWeek = this.getDayOfWeek(appointment.dateTime);
    const schedules = await this.doctorRepo.getSchedulesByDoctorAndDay(newDoctorId, dayOfWeek);
    if (!this.isWithinSchedule(appointment.dateTime, schedules)) {
      throw new Error('New doctor is not available at the scheduled time');
    }
    // Check for conflicting appointments for the new doctor
    const conflict = await this.appointmentRepo.hasConflictingAppointment(newDoctorId, appointment.dateTime);
    if (conflict) {
      throw new Error('New doctor already has an appointment at that time');
    }
    // Update the appointment with the new doctor
    await this.appointmentRepo.updateDoctor(appointmentId, newDoctorId);
  }

  /**
   * Cancels an appointment if it's still scheduled and more than 24 hours remain.
   */
  public async cancelAppointment(appointmentId: number): Promise<void> {
    // Retrieve the appointment
    const appointment = await this.appointmentRepo.findById(appointmentId);
    if (!appointment) {
      throw new Error('Appointment not found');
    }
    // Only scheduled appointments can be canceled
    console.log(appointment)
    if (appointment.status !== 'scheduled') {
      throw new Error('Only scheduled appointments can be canceled');
    }
    // Do not allow cancellation if less than 24 hours remain
    const now = new Date();
    const diffHours = (appointment.dateTime.getTime() - (now.getTime()-(5*60*60*1000))) / (1000 * 60 * 60);//add 5 hours TMZ
   
    if (diffHours < 24) {
      throw new Error('Cannot cancel appointment within 24 hours of its scheduled time');
    }
    await this.appointmentRepo.updateStatus(appointmentId, 'canceled');
  }

  /**
   * Helper method that returns the day of the week (e.g., "Monday") for a given date.
   */
  private getDayOfWeek(date: Date): string {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    return days[date.getDay()];
  }

  /**
   * Checks if the given appointment time falls within any of the available schedules.
   * Converts the appointment time to minutes and compares it with the start and end times (also converted to minutes).
   */
  private isWithinSchedule(dateTime: Date, schedules: any[]): boolean {

    const appointmentMinutes = dateTime.getUTCHours() * 60 + dateTime.getUTCMinutes();
   
    return schedules.some(schedule => {
      // Assume schedule.startTime and schedule.endTime are strings in "HH:MM" format
      const [startH, startM] = schedule.startTime.split(':').map(Number);
      const [endH, endM] = schedule.endTime.split(':').map(Number);
      const start = startH * 60 + startM;
      const end = endH * 60 + endM;
      return appointmentMinutes >= start && appointmentMinutes <= end;
    });
  }
}
